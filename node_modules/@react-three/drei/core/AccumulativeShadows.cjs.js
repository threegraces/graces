"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e=require("@babel/runtime/helpers/extends"),t=require("three"),r=require("react"),a=require("@react-three/fiber");function i(e){return e&&"object"==typeof e&&"default"in e?e:{default:e}}function s(e){if(e&&e.__esModule)return e;var t=Object.create(null);return e&&Object.keys(e).forEach((function(r){if("default"!==r){var a=Object.getOwnPropertyDescriptor(e,r);Object.defineProperty(t,r,a.get?a:{enumerable:!0,get:function(){return e[r]}})}})),t.default=e,Object.freeze(t)}var n=i(e),o=s(t),h=s(r);const l=h.createContext(null),u=h.forwardRef((({children:e,temporal:t,frames:r=40,blend:i=20,scale:s=10,opacity:n=1,alphaTest:u=.65,color:c="black",resolution:d=1024,...g},f)=>{const m=a.useThree((e=>e.gl)),v=a.useThree((e=>e.scene)),M=a.useThree((e=>e.camera)),b=h.useRef(null),w=h.useRef(null),[y]=h.useState((()=>new p(m,v,d)));h.useLayoutEffect((()=>{y.configure(b.current)}),[]);const S=h.useMemo((()=>{const e=Object.assign(new o.MeshBasicMaterial({opacity:0,transparent:!0,dithering:!0,depthWrite:!1,map:y.progressiveLightMap2.texture}),{uniforms:{ucolor:{value:new o.Color(c)},alphaTest:{value:0}}});return e.onBeforeCompile=t=>{e.uniforms=t.uniforms={...t.uniforms,...e.uniforms},t.fragmentShader=t.fragmentShader.replace("void main() {","uniform vec3 ucolor;\n           uniform float alphaTest;\n           void main() {"),t.fragmentShader=t.fragmentShader.replace("#include <dithering_fragment>","#include <dithering_fragment>\n           gl_FragColor = vec4(ucolor * gl_FragColor.r * 2.0, max(0.0, (1.0 - gl_FragColor.r / alphaTest)) * opacity);")},e}),[c]),x=h.useMemo((()=>({lights:new Map,temporal:!!t,frames:Math.max(2,r),blend:Math.max(2,r===1/0?i:r),count:0,reset:()=>{y.clear(),S.opacity=0,S.uniforms.alphaTest.value=0,x.count=0},update:(e=1)=>{x.temporal?(S.opacity=Math.min(n,S.opacity+n/x.blend),S.uniforms.alphaTest.value=Math.min(u,S.uniforms.alphaTest.value+u/x.blend)):(S.opacity=n,S.uniforms.alphaTest.value=u),w.current.visible=!0,y.prepare();for(let t=0;t<e;t++)x.lights.forEach((e=>e.update())),y.update(M,x.blend);w.current.visible=!1,y.finish()}})),[y,S,M,v,t,r,i,n,u]);return h.useLayoutEffect((()=>{x.reset(),x.temporal||x.frames===1/0||x.update(x.blend)})),h.useImperativeHandle(f,(()=>x),[]),a.useFrame((()=>{(x.temporal||x.frames===1/0)&&x.count<x.frames&&(x.update(),x.count++)})),h.createElement("group",g,h.createElement("group",{traverse:()=>null,ref:w},h.createElement(l.Provider,{value:x},e)),h.createElement("mesh",{receiveShadow:!0,ref:b,material:S,scale:s,rotation:[-Math.PI/2,0,0]},h.createElement("planeGeometry",null)))})),c=h.forwardRef((({castShadow:e=!0,bias:t=0,mapSize:r=512,size:a=5,near:i=.5,far:s=500,frames:u=1,position:c=[0,0,0],radius:d=1,amount:p=8,intensity:g=1,ambient:f=.5,...m},v)=>{const M=h.useRef(null),b=new o.Vector3(...c).length(),w=h.useContext(l),y=h.useCallback((()=>{let e;if(M.current)for(let t=0;t<M.current.children.length;t++)if(e=M.current.children[t],Math.random()>f)e.position.set(c[0]+o.MathUtils.randFloatSpread(d),c[1]+o.MathUtils.randFloatSpread(d),c[2]+o.MathUtils.randFloatSpread(d));else{let t=Math.acos(2*Math.random()-1)-Math.PI/2,r=2*Math.PI*Math.random();e.position.set(Math.cos(t)*Math.cos(r)*b,Math.abs(Math.cos(t)*Math.sin(r)*b),Math.sin(t)*b)}}),[d,f,b,...c]),S=h.useMemo((()=>({update:y})),[y]);return h.useImperativeHandle(v,(()=>S),[S]),h.useLayoutEffect((()=>{const e=M.current;return w&&w.lights.set(e.uuid,S),()=>{w.lights.delete(e.uuid)}}),[w,S]),h.createElement("group",n.default({ref:M},m),Array.from({length:p},((n,o)=>h.createElement("directionalLight",{key:o,castShadow:e,"shadow-bias":t,"shadow-mapSize":[r,r],intensity:g/p},h.createElement("orthographicCamera",{attach:"shadow-camera",args:[-a,a,a,-a,i,s]})))))}));class d extends o.ShaderMaterial{constructor(){super({vertexShader:"void main() { gl_Position = vec4((uv - 0.5) * 2.0, 1.0, 1.0); }",fragmentShader:"void main() { discard; }"})}}class p{constructor(e,t,r=1024){this.renderer=e,this.res=r,this.scene=t,this.scene.background=null,this.buffer1Active=!1,this.lights=[],this.meshes=[],this.object=null;const a=/(Android|iPad|iPhone|iPod)/g.test(navigator.userAgent)?o.HalfFloatType:o.FloatType;this.progressiveLightMap1=new o.WebGLRenderTarget(this.res,this.res,{type:a}),this.progressiveLightMap2=new o.WebGLRenderTarget(this.res,this.res,{type:a}),this.uvMat=new d,this.targetMat=new o.MeshPhongMaterial({shininess:0}),this.previousShadowMap={value:this.progressiveLightMap1.texture},this.averagingWindow={value:100},this.targetMat.onBeforeCompile=e=>{e.vertexShader="varying vec2 vUv;\n"+e.vertexShader.slice(0,-1)+"vUv = uv; gl_Position = vec4((uv - 0.5) * 2.0, 1.0, 1.0); }";const t=e.fragmentShader.indexOf("void main() {");e.fragmentShader=e.fragmentShader.replace("#include <clipping_planes_pars_fragment>","#include <clipping_planes_pars_fragment>\n#include <shadowmask_pars_fragment>\n"),e.fragmentShader="varying vec2 vUv;\n"+e.fragmentShader.slice(0,t)+"\tuniform sampler2D previousShadowMap;\n\tuniform float averagingWindow;\n"+e.fragmentShader.slice(t-1,-1)+"\nvec3 texelOld = texture2D(previousShadowMap, vUv).rgb;\n        gl_FragColor.rgb = mix(texelOld, gl_FragColor.rgb, 1.0/averagingWindow);\n      }",e.uniforms.previousShadowMap=this.previousShadowMap,e.uniforms.averagingWindow=this.averagingWindow}}clear(){this.renderer.setRenderTarget(this.progressiveLightMap1),this.renderer.clear(),this.renderer.setRenderTarget(this.progressiveLightMap2),this.renderer.clear(),this.lights=[],this.meshes=[],this.scene.traverse((e=>{!function(e){return!!e.geometry}(e)?function(e){return e.isLight}(e)&&this.lights.push({object:e,intensity:e.intensity}):this.meshes.push({object:e,material:e.material})}))}prepare(){this.lights.forEach((e=>e.object.intensity=0)),this.meshes.forEach((e=>e.object.material=this.uvMat))}finish(){this.lights.forEach((e=>e.object.intensity=e.intensity)),this.meshes.forEach((e=>e.object.material=e.material))}configure(e){this.object=e}update(e,t=100){if(!this.object)return;this.averagingWindow.value=t,this.object.material=this.targetMat;const r=this.buffer1Active?this.progressiveLightMap1:this.progressiveLightMap2,a=this.buffer1Active?this.progressiveLightMap2:this.progressiveLightMap1;this.renderer.setRenderTarget(r),this.previousShadowMap.value=a.texture,this.buffer1Active=!this.buffer1Active,this.renderer.render(this.scene,e),this.renderer.setRenderTarget(null)}}exports.AccumulativeShadows=u,exports.RandomizedLight=c,exports.accumulativeContext=l;
